SerExpanGregoryLeibniz:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $40, %esp //размер стекового кадра
        movl    8(%ebp), %eax
        movl    12(%ebp), %edx
        movl    %eax, -40(%ebp) //записали N
        movl    %edx, -36(%ebp)
        fldz //команда помещает в стек FPU часто используемые константы (во временном вещественном формате) загрузить константу +0.0

        fstpl   -8(%ebp) //занесли на стек 0.0 res
        fld1 //загружает константу на стек сопроцессора 1.0
        fstpl   -16(%ebp) //занесли на стек signDef = 1.0
        movl    $0, -20(%ebp) //инициальизация i = 0
        jmp     .L2
.L3:
        fldl    -16(%ebp) //загружаем signDef
        fldl    .LC2
        fmulp   %st, %st(1) //перемножили 4*signDef
        fildl   -20(%ebp) // Команда FILD преобразует знаковый целочисленный операнд-источник в формат временного вещественного и помещает его в регистровый стек FPU для i
        fld     %st(0) //теперь сохраняем на стеке сопроцессора
        faddp   %st, %st(1) //i+i
        fld1 //загрузили константу на стек сопроцессора
        faddp   %st, %st(1) //сложили 2*i + 1.0
        fdivrp  %st, %st(1) //Инверсное деление с извлечением из стека st/st(1)
        fldl    -8(%ebp) //загрузили значение в res
        faddp   %st, %st(1)
        fstpl   -8(%ebp) //загрузили на стек res
        fldl    -16(%ebp) //погрузили signDef FPU
        fchs //эта операция изменяет положительное значение на отрицательное значение теперь поменяли знак
        fstpl   -16(%ebp) //Команда FST копирует текущее значение из регистра ST в -16(%ebp)
        addl    $1, -20(%ebp) // увеличили i на 1
.L2:
        movl    -40(%ebp), %eax //достаём N из стека
        cmpl    %eax, -20(%ebp) // сравнили в цикле
        jl      .L3
        fldl    -8(%ebp) 
        leave
        ret
main:
//Выравнивание бит
        leal    4(%esp), %ecx
        andl    $-16, %esp //1111
        pushl   -4(%ecx) //помещает адрес возврата из функции на вершину стека

// формирование стекового кадр
        pushl   %ebp //добавить адрес возврата в стек
        movl    %esp, %ebp //копировавние указателя, то есть два указтеля сравнялись
        pushl   %ecx //добавить в стек содержимое %ecx количество аргументов функции
        subl    $52, %esp //вычитаем из esp 52, формируем стек
        movl    %ecx, %eax //скопировали в регистр eax
        
        cmpl    $2, (%eax) //сравнили 2 и eax
        je      .L6 //если условие ложно,  то переходим на след этап
        
        movl    $1, %eax //иначе записали в регистр 1 и по метке выходим из программы
        
        jmp     .L7
.L6:
        movl    4(%eax), %eax //достаем значение N из argv[argc]
        addl    $4, %eax
        movl    (%eax), %eax //разыменовываем rax и заносит в rax
        subl    $12, %esp
        pushl   %eax
        call    atoll
        addl    $16, %esp
        movl    %eax, -16(%ebp) //занесли значение N на стек
        movl    %edx, -12(%ebp) //edx 32-битных регистров, которые могут использоваться программистами для хранения данных и адресов (регистры общего назначения) вероятно занесли argv[argv]
        
        subl    $8, %esp
        pushl   -12(%ebp) // вероятно занесли на стек argv[argv]
        pushl   -16(%ebp) //занесли N
        call    SerExpanGregoryLeibniz вызов функции
        addl    $16, %esp
        fstpl   -24(%ebp) //занесли на стек результат работы функции
        movl    $0, %eax //возврат ноль
.L7:
        movl    -4(%ebp), %ecx
        leave
        leal    -4(%ecx), %esp
        ret
.LC2:
     .long   0
     .long   1074790400
