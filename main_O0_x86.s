
main:
//Выравнивание бит
        leal    4(%esp), %ecx
        andl    $-16, %esp //1111
        pushl   -4(%ecx) //помещает адрес возврата из функции на вершину стека

SerExpanGregoryLeibniz:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $32, %esp  //размер стекового кадра
        fldz //команда помещает в стек FPU часто используемые константы (во временном вещественном формате) загрузить константу +0.0

        fstpl   -8(%ebp) //занесли на стековый кадр 0.0 res
        fld1 //загрузили константу на стек сопроцессора 1.0
        fstpl   -16(%ebp)  //загружает константу на стековый кадр
        movl    $0, -20(%ebp)  //инициальизация i = 0
        jmp     .L2
.L3:
        fldl    -16(%ebp)  //signDef = 1.0 загрузили signDef на стек сопроцессора
        fldl    .LC2 //4.0 загрущили на стек сопроцессора
        fmulp   %st, %st(1) //перемножили 4*signDef
        fildl   -20(%ebp) //Команда fild преобразует знаковый целочисленный операнд-источник в формат временного вещественного и помещает его в регистровый стек FPU для i
        fld     %st(0)    //теперь сохраняем на стеке сопроцессора
        faddp   %st, %st(1) //таким образом представили i+i
        fld1 //загрущили на стек сопроцессора 1.0
        faddp   %st, %st(1) ////сложили 2*i + 1.0 выкидываем st(0)
        fdivrp  %st, %st(1)  //деление с извлечением из стека st/st(1)
        fldl    -8(%ebp)  //загрузили значение res на стек сопроцессора
        faddp   %st, %st(1) //теперь сложили предыдущий res с текущем
        fstpl   -8(%ebp)    //команда FST копирует текущее значение из регистра ST в -16(%ebp)
        fldl    -16(%ebp)    //погрузили signDef FPU
        fchs //эта операция изменяет положительное значение на отрицательное значение теперь поменяли знак

        fstpl   -16(%ebp) //занесли на стек результат signDef
        addl    $1, -20(%ebp) //i++
.L2:
        movl    -20(%ebp), %eax //достаём i из стека
        cmpl    8(%ebp), %eax //сравнили в цикле i N
        jl      .L3 #,
        fldl    -8(%ebp) //поместили на стек сопроцессора res
        leave
        ret
.LC4:
        .string "%lf"
main:
//Выравнивание бит
        leal    4(%esp), %ecx
        andl    $-16, %esp

        pushl   -4(%ecx)
        pushl   %ebp  //добавить адрес возврата в стек
        movl    %esp, %ebp //копировавние указателя, то есть два указтеля сравнялись
        pushl   %ecx //добавить в стек содержимое %ecx количество аргументов функции
        subl    $20, %esp  //вычитаем из esp 20, формируем стек
        movl    %ecx, %eax  //скопировали в регистр eax
        cmpl    $2, (%eax)   //сравнили 2 и eax то есть argc
        
je      .L6 //если условие ложно,  то переходим на след этап
        movl    $1, %eax  //записалаи 1 в eax
        jmp     .L7  //иначе записали в регистр 1 и по метке выходим из программы

.L6:
        movl    4(%eax), %eax  //достаем значение N из argv[argc]
        addl    $4, %eax
        movl    (%eax), %eax
        subl    $12, %esp //увеличели стековый кадр
        pushl   %eax //адрес возврата функции
        call    atoi
        
        addl    $16, %esp
        movl    %eax, -12(%ebp) # tmp87, N
        subl    $12, %esp
        pushl   -12(%ebp) //записали в переменную N результат работы функции atoi
        call    SerExpanGregoryLeibniz
        
        addl    $16, %esp
        fstpl   -24(%ebp) //команда FST копирует текущее значение из регистра ST в  -24(%ebp) res
        fldl    -16(%ebp) //погрузили signDef FPU
        subl    $4, %esp
        pushl   -20(%ebp)  # res
        pushl   -24(%ebp)  # res
        pushl   $.LC4
        call    printf
       
        addl    $16, %esp
        movl    $0, %eax   //возвращаем ноль
.L7:
        movl    -4(%ebp), %ecx
        leave
        leal    -4(%ecx), %esp //адрес возврата из функции на вершину стека
        ret
.LC2:
        .long   0
        .long   1074790400 // 4.0
