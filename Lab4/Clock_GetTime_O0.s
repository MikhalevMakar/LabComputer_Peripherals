SerExpanGregoryLeibniz:
        push    {r7} //добавили на стек r7
        sub     sp, sp, #36 //размер стекового фрейма sp = sp-36
        add     r7, sp, #0  /r7 = sp
        str     r0, [r7, #4]  //добавили на стек r0 = N
        mov     r2, #0  //r2 = 0 первая часть res
        mov     r3, #0    //r3 = 0 вторая часть res
        strd    r2, [r7, #24] //добавили в стек res, d-double
        mov     r2, #0  //первая часть числа signDef
        mov     r3, #0  //занулили r3 = 0
        movt    r3, 16368 //0011 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 = (-1)^0*2^(1023-1023)*1,0 = 1.0, вторая часть signDef
        strd    r2, [r7, #16] // положили signDef в стек
        movs    r3, #0 //i = 0
        str     r3, [r7, #12]  //положили i в стек
        b       .L2 //перешли по безусловной метке
.L3:
        vldr.64         d16, [r7, #16] //положили signDeg в d16
        vmov.f64        d17, #4.0e+0  // d17 = 4*10^0
        vmul.f64        d18, d16, d17 //перемножили 4*signDeg и положили в d18
        ldr             r3, [r7, #12]  //поместили в r3 = i
        vmov            s15, r3  //скопировали в s15 = i то есть перевели int  в вещественый тип
        vcvt.f64.s32   d16, s15  //перевели в double d16 = i
        vadd.f64        d16, d16, d16  //сложили d16 = i+i
        vmov.f64        d17, #1.0e+0   //d17 = 1
        vadd.f64        d17, d16, d17 //d17 = 2i+1
        vdiv.f64        d16, d18, d17  // d16 =  d18 / d17 = 4*signDeg / (2i+1)
        vldr.64         d17, [r7, #24]  // загрузили со стека в d17 = res
        vadd.f64        d16, d17, d16  //сложили d16 = d17 + d16 = res + (4*signDeg / (2i+1) )
        vstr.64         d16, [r7, #24]   //загрузили в стек d16
        vldr.64         d16, [r7, #16]  //загрузили из памяти в регистр d16 = signDef
        vneg.f64        d16, d16  //Отрицание числа в формате с плавающей точкой
        vstr.64         d16, [r7, #16]  //загрузили на стек signDef
        ldr             r3, [r7, #12]  //загрузили r3 = i
        adds            r3, r3, #1  //r3 = i++
        str             r3, [r7, #12]  //загрузили в стек r3 = i
.L2:
        ldr     r2, [r7, #12] //загрузили переменую  i
        ldr     r3, [r7, #4] //загрузили N из стека
        cmp     r2, r3  //сравнили i < N
        blt     .L3 // если условие выполнилось, то .L3
        ldrd    r2, [r7, #24] //в r2 загрузили res
        vmov    d16, r2, r3  //в d16 скопировали res
        vmov.f64 d0, d16 //в d0 = d16
        adds    r7, r7, #36  //вернуть 36 байтов, зарезервированные для локальныз переменных
        mov     sp, r7   //записать r7 в sp (сбрасываем кадр стека)
        ldr     r7, [sp], #4 //r7 = sp+4
        bx      lr  //команда bx выполняет переход по адресу, заданному в регистре
.LC0:
        .ascii  "%lf\000"
main:
        push    {r7, lr}  //занесли на стек регистры r7, lr((r14, в котором хранится вектор возврата при вызове функций). Когда SP используется по прямому назначению, он должен содержать значение, кратное 4, поскольку обращение к стеку выполняется словами.
//вероятно, выравнивания стека вызовов в 8 байтов.

//формирование стекового кадра
        sub     sp, sp, #24  //выделили 24 байта под стековый кадр sp = sp-24
        add     r7, sp, #0  //это регистр r11 - регистр стекового фрейма, а base pointer в x86 — указатель базы стекового фрейма r7 = ebp

//добавили аргументы функции main в стековый фрейм
        str     r0, [r7, #4] //сохранить содержимое r0 по адресу в r7+4, положили на стек argc
        str     r1, [r7] //сохранить содержимое r1 = argv по адресу r7
        ldr     r3, [r7, #4] //загружает значение по адресу, найденному в R7+4, в регистр r3 = argc

//условный оператор
        cmp     r3, #2  //сравнили argc == 2
        beq     .L6  //метка переход, если установлен Z(равно)
        movs    r3, #1  //иначе в регистр занесли r3 = 1
        b       .L7  //перешли на метку .L7
.L6:
        ldr     r3, [r7]  //загрузили  в r3 = argv

//Вызов функции и передача параметра N
        adds    r3, r3, #4  //r3 = r3 + 4 теперь в r3 хранится адрес argv[1] = N
        ldr     r3, [r3]  //загрузили в r3 значение N, r3 = N
        mov     r0, r3  //сохранили r3 в r0, r0 = r3 = N
        bl      atoll  //вызов ф-ии atoll, bl сохраняет адрес возврата (адрес команды, следующей за BL) в регистр LR14 и выполняют переход на указанный адрес.

//вызов ф-ии SerExpanGregoryLeibniz и передача аргументов в ф-ию
        mov     r2, r0  //сохранить r0 в r2, r2 = r0 = N
        mov     r3, r1  //r3 = r1 = argv[0]
        mov     r3, r2  // r3 = N
        str     r3, [r7, #20] //сохранить содержимое по адресу r7+20 => r3 = N
        ldr     r0, [r7, #20]  //загрущили со стека  в r0 = N
        bl      SerExpanGregoryLeibniz

        vstr.64 d0, [r7, #8] //загрузили res в стек
        ldrd    r2, [r7, #8]  //загрузить второй аргумент printf r2 = res
        movw    r0, #:lower16:.LC0
        movt    r0, #:upper16:.LC0  //поместить указатель на строку из метки .LC0 в r0 (первый аргумент printf)
        bl      printf
        movs    r3, #0 // r3 = 0
.L7:
        mov     r0, r3  <retval> //вовзращаемое значение результат работы main
        adds    r7, r7, #24 //востанвливаем стековый фрейм выделеные 24 байта
        mov     sp, r7 //копирование r7 в sp. в x86 это esp копируем в ebp.
        pop     {r7, pc} //возврат из подпрограммы, где lr был помещен в стек в начале подпрограммы.

    
//Регистр r15 используется как счетчик команд (program counter, instruction pointer). PC
//Регистр PC (Program Counter) используется для хранения адресов выполняющихся команд. При последовательном выполнении команд он последовательно увеличивается, при перехода//прерываниях в него загружается новое значение.

//Регистр r14 используется для сохранения адреса возврата в результате исполнения специальной команды условного перехода. LR

//Регистр r13 обычно используется как указатель вершины стека (stack pointer), хотя и не поддержан специально программной архитектурой. SP

//R11 помогает нам отслеживать границы в стеке, выступая в качестве указателя кадра (будет рассмотрен позже)

//Кроме того, соглашение о вызове функции на ARM указывает, что первые четыре аргумента функции хранятся в регистрах r0-r3.

//r7 используется для хранения номера системного вызова. Системные вызовы очень похожи на вызовы функций, в том смысле, что в них передаются аргументы и они возвращают значения. Единственное отличие состоит в том, что системные вызовы работают на уровне ядра, а функции нет.

//BL выполняют переход на указанный адрес. BL, кроме того, сохраняет адрес возврата (адрес команды, следующей за BL) в регистре LR (R14).
