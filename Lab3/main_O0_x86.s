SerExpanGregoryLeibniz:
        pushl   %ebp //начинает формироваться стековый кадр, путем помещения регистра ebp на вершину стека
        movl    %esp, %ebp //копировавние указателя, то есть два указтеля сравнялись
        subl    $32, %esp  //размер стекового кадра
        fldz //команда помещает в стек FPU часто используемые константы (во временном вещественном формате) загрузить константу +0.0

        fstpl   -8(%ebp) //занесли на стековый кадр 0.0 res
        fld1 //загрузили константу на стек сопроцессора 1.0
        fstpl   -16(%ebp) //загружает константу на стековый кадр
        movl    $0, -20(%ebp) //инициальизация i = 0
        jmp     .L2
.L3:
        fldl    -16(%ebp) //signDef = 1.0 загрузили signDef на стек сопроцессора
        fldl    .LC2 //4.0 загрущили на стек сопроцессора
        fmulp   %st, %st(1) //перемножили 4*signDef
        fildl   -20(%ebp) //Команда fild преобразует знаковый целочисленный операнд-источник в формат временного вещественного и помещает его в регистровый стек FPU для i
        fld     %st(0) //теперь сохраняем на стеке сопроцессора
        faddp   %st, %st(1) //таким образом представили i+i
        fld1 //загрущили на стек сопроцессора 1.0
        faddp   %st, %st(1) ////сложили 2*i + 1.0 выкидываем st(0)
        fdivrp  %st, %st(1)  //деление с извлечением из стека st/st(1)
        fldl    -8(%ebp)  //загрузили значение res на стек сопроцессора
        faddp   %st, %st(1) //теперь сложили предыдущий res с текущем
        fstpl   -8(%ebp) //команда FST копирует текущее значение из регистра ST в -16(%ebp)
        fldl    -16(%ebp) //погрузили signDef FPU
        fchs //эта операция изменяет знак значение теперь поменяли знак singDef

        fstpl   -16(%ebp) //занесли на стек результат signDef
        addl    $1, -20(%ebp) //i++
.L2:
        movl    -20(%ebp), %eax //достаём i из стека
        cmpl    8(%ebp), %eax //сравнили в цикле i N
        jl      .L3 //безусловный переход на метку .L3
        fldl    -8(%ebp) //поместили на стек сопроцессора res
        leave //сохранить указатель стека вызывающего абонента (esp), обычно это не требуется, обычно esp вызывающего абонента = ebp вызывающего абонента + 4
//возвращает stack pointer к состоянию до выравнивания по 16-байтам
        ret //Команда RET читает из стека адрес возврата и заносит его в регистр IP, передавая таким образом управление
.LC4:
        .string "%lf"
main:
//Выравнивание бит
        leal    4(%esp), %ecx  //помещает адрес нулевого аргумента, переданного основной функции, в регистр ecx
//вычисляет эффективный адрес ИСТОЧНИКА и помещает его в ПРИЁМНИК
        andl    $-16, %esp //-16 == 0xfffffff0
        pushl   -4(%ecx) //сохранили в стеке адрес возврата

//формирование стекового кадра
        pushl   %ebp  //начинает формироваться стековый кадр, путем помещения регистра ebp на вершину стека
        movl    %esp, %ebp //копировавние указателя, то есть два указтеля сравнялись
        pushl   %ecx //добавить в стек содержимое %ecx количество аргументов функции argc
        subl    $20, %esp  //вычитаем из esp 20, формируем стек
        
        movl    %ecx, %eax //скопировали в регистр eax
        cmpl    $2, (%eax) //сравнили 2 и eax то есть argc
        
je      .L6 //если условие ложно,  то переходим  на метку .L6 и продолжается программа
        movl    $1, %eax //записалаи 1 в eax
        jmp     .L7  //иначе записали в регистр 1 и по метке выходим из программы

.L6:
        movl    4(%eax), %eax  //достаем значение N из argv[argc] = N
        addl    $4, %eax //eax = eax + 4 // перешли *argv[argc] = N
        movl    (%eax), %eax //разыменование указателя argv[argc] = N
        subl    $12, %esp //увеличели стековый кадр
        pushl   %eax //добавили в стек argv[argc]
        call    atoi
        
        addl    $16, %esp //уменьшили стековый кадр
        movl    %eax, -12(%ebp) //записали на стековый кадр N
        subl    $12, %esp // esp -=12
        pushl   -12(%ebp) //записали в переменную N результат работы функции atoi
        call    SerExpanGregoryLeibniz
        
        addl    $16, %esp //esp += 16
        fstpl   -24(%ebp) //команда FST копирует текущее значение из регистра ST в  -24(%ebp) res
        fldl    -16(%ebp) //погрузили signDef FPU
        subl    $4, %esp // esp -= 4
        pushl   -20(%ebp) //записали на  стек res
        pushl   -24(%ebp) //записали на  стек res
        pushl   $.LC4 //кладется строковый литерал на вершину стека
        call    printf
       
        addl    $16, %esp //esp += 16
        movl    $0, %eax //возвращаем ноль
.L7:
        movl    -4(%ebp), %ecx //адрес во
        leave // Это эквивалентно movl %ebp, %esp; Так мы восстанавливаем состояние стека и кадра, которые были до вызова
                               // popl %ebp
        leal    -4(%ecx), %esp //сохранить указатель стека вызывающего абонента (esp), обычно это не требуется, обычно esp вызывающего абонента = ebp вызывающего абонента + 4
//возвращает stack pointer к состоянию до выравнивания по 16-байтам
        ret //Команда RET читает из стека адрес возврата и заносит его в регистр IP, передавая таким образом управление
.LC2:
        .long   0
        .long   1074790400 // 4.0

//Эффективный адресс как формируется:
//это БАЗА + СМЕЩЕНИЕ + ИНДЕКС
//где БАЗА - это базовый адрес
//СМЕЩЕНИЕ - это константа, заданная в команде;
//ИНДЕКС - значение индексного регистра

//andl  $-16, %esp
//%esp немного изменен, так что он становится кратным 16. Для некоторых типов данных (формат с плавающей запятой, соответствующий double и long double в C) производительность выше, когда доступ к памяти осуществляется по адресам, кратным 16.
//которая выравнивает указатель стека вверх (нижний адрес) до ближайшего адреса, который можно разделить на 16 (-16 == 0xfffffff0)
